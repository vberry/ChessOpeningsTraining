# Transforms positions and notes from an sqlite db of the CPT/COT (?) old ipad app
# into the creation of a graph for the neo4j graph database system

# in v2 we try to solve this pbm:
# with constraints, elements of the graph are slower to generate
#
# - we define constraints first as proposed by best practices
# - we use MERGE and not CREATE as it can use the index defined by the constraint to quickly check that no such node with same id exists
# - we add indexes to accelerate future queries 


import sqlite3
import sys
import chess
import re
from os import listdir
from os.path import isfile, join

from os import listdir
from os.path import isfile, join

def get_COT_formatted_fen(board):
    ''' remove the last part of the fen generated by the chess module as this part is not stored with positions in the COT database'''
    m = re.search(r'(.*)\s+\d+\s+\d+',board.fen())
    if m:
        return m.group(1)
    else:
        print('function get_COT_formatted_fen: regexp not correct to remove last part of large fen')
        sys.exit(-1)

def fen_after_move(fen,move):
    '''Generate the fen of the position obtained by playing <move> on the given <fen>'''
    board = chess.Board(fen)
    board.push_san(move)
    return get_COT_formatted_fen(board)

##########    MAIN   #################
if len(sys.argv)<2:
    print("\t\tUsage: "+sys.argv[0]+' <folder_containing_sqlite files>')
    sys.exit(-1)
mypath = sys.argv[1]

index = 0 ; files = []
for f in listdir(mypath):
    if isfile(join(mypath, f)) and f.endswith('.sqlite'):
        print(index,' : ',f)
        files.append(f) ; index += 1
choice = int(input('Which file to transform? '))
filename=join(mypath, files[choice])
con = sqlite3.connect(filename)
cur = con.cursor()
###  GET all positions : 
cur.execute("SELECT id,fromfen,move,ordinal FROM positions")
positionsLITE = cur.fetchall()
print('nb of positions in this opening book = ',len(positionsLITE)) 

# Load positions in a dictionary
SQlite_positions = {}  
SQlite_from_fens = {} 
for (id,fromfen,move,ordinal) in positionsLITE:
    if id in SQlite_positions:
        print('ERROR: id ',id,' is not unique in the sqlite db!')
        sys.exit(-1)
    SQlite_positions[id] = {'fromfen':fromfen,'move':move,'ordinal':ordinal}
    if fromfen in SQlite_from_fens: 
        SQlite_from_fens[fromfen].append((id,move)) 
    else: 
        SQlite_from_fens[fromfen] = [(id,move)] # adds the move of the SQlite position and ordinal of this move

# Generate data structures for the positions and moves to be stored in the graph db
nodes = {} # fen to id in the graphDB
moves = {} # move_id relating a 'from' and a 'to' positions (the move_id is taken from the SQLite position)

# Adds the initial position in the graphDB with id 0
if 0 in SQlite_positions:
    print("Houston we have a pbm: id 0 is already taken by a 'position' of the SQlite db")
    sys.exit(-2)

init_fen = get_COT_formatted_fen(chess.Board())
nodes[init_fen] = 0 ; node_id = 1 # ready for next node addition

# In fact each 'position in the SQlite DB is in fact a move" -> we prepare it as this in the graphDB
for id in SQlite_positions:
    # if id already seen we have duplicate ids:
    if id in moves:
        print("Duplicate position ids in SQlite db")
        sys.exit(-1)
    # is the starting position already known? Otherwise we create it for the graphDB
    starting_fen = SQlite_positions[id]['fromfen']
    if starting_fen not in nodes:
        nodes[starting_fen] = node_id ; node_id += 1
    # for this position we reach a new position:
    resulting_fen = fen_after_move(starting_fen,SQlite_positions[id]['move'])
    #print('resulting board :', chess.Board(resulting_fen))
    # we add this posÂ° node if not already registered (could be because of different move order)
    if resulting_fen not in nodes:
        nodes[resulting_fen] = node_id ; node_id += 1
    # Now we add the move between the two
    moves[id] = {'label': SQlite_positions[id]['move'], 'from': starting_fen, 'to':resulting_fen, 'ordinal':SQlite_positions[id]['ordinal']} 

print('Nb of nodes for the graph DB = ',len(nodes.keys()))
print('Nb of moves for the graph DB = ',len(moves.keys()))

# Getting notes stored in the opening book
cur.execute("SELECT notes.note, notes.fromfen, notes.id from notes")
notes = cur.fetchall() # tuples (comment,fen)
# Adding notes to the corresponding fen
unreferenced = 0
for (comment,fen,id) in notes:
    if fen not in nodes:
        # sometimes a note is not in the positions table or obtained from it (ie, the sqlite db was not correctly maintained)
        # print('PBM: note %s corresponds to a position note in the Positions table!' % id)
        # print('comment is ',comment)
        # print('fens is: ',fen)
        unreferenced += 1
    else:
        nodes[fen] = (nodes[fen], comment) # (id,comment)
print('Skipping %d notes not corresponding to actual positions' % unreferenced)
print('Reporting %d notes' % (len(notes)-unreferenced))

################## Creating graph nodes 
CREATION=[]

############# 1) Adding constraints
CREATION.append('CREATE CONSTRAINT pos_uniq_id FOR (p:Position) REQUIRE p.id IS UNIQUE  ;')
CREATION.append('CREATE CONSTRAINT mov_uniq_id FOR ()-[m:Move]->() REQUIRE m.id IS UNIQUE ;')
# Only available in the entreprise edition:
# CREATION.append('CREATE CONSTRAINT FOR (p:Position)  REQUIRE (p.fen) IS NOT NULL;')

############ 2) Creating Position nodes
stop = 5
for fen,content in nodes.items():
    if type(content) == tuple:
        (id,comment) = content
        # handling quote characters as we use quote for the neo4j litteral:
        #comment = 'a nice " ouble quote"'
        comment = comment.replace("'","\\'") # single quotes
        comment = comment.replace('"','\\"') # double quotes
        # '\n' two-character sequence is not a pbm (checked) 
        CREATION.append( "MERGE (n"+str(id)+":Position {id: "+str(id)+"})" + \
                    " ON CREATE SET n"+str(id)+".fen ='" + fen + "', n"+str(id)+".comment = '" + \
                     comment+"';" ) 
    else:
        id = content
        CREATION.append( "MERGE (n"+str(id)+":Position {id: "+str(id)+"})" + \
                        " ON CREATE SET n"+str(id)+".fen ='" + fen + "';" ) 
        
#print(CREATION)
    # stop -= 1
    # if stop == 0:  
    #     break
# sys.exit(1)

#####       IMPORTANT NOTE: if we put a ';' here in CREATION in between nodes and relationship creation 
#####           this ends the current transaction so that we cannot use n<id> nodes variable anymore,
#####           it makes the db server create new nodes instead of referring to those we created


####### 3) Adding indexes on Positions to make queries faster:
CREATION.append(';') # to be sure to end previous transactions
CREATION.append('CREATE INDEX i_pos_fen FOR (p:Position) ON p.fen;') # in case we need to look for a node from its fen
CREATION.append('CREATE FULLTEXT INDEX i_pos_comment FOR (p:Position) ON EACH [p.comment]') # as we will allow to search comments later on
#CREATION.append('CREATE INDEX i_pos_id FOR (p:Position) ON p.id;') # <- forbidden  as there is already a constraint ensuring this


############ 4) Create Move relationships
stop = 3
CREATION.append(';') # making move creation a separate transaction to observe execution times separately
for m_id in moves:
    move = moves[m_id]['label']
    from_fen = moves[m_id]['from']
    to_fen = moves[m_id]['to']
    ordinal = moves[m_id]['ordinal']
    s_content = nodes[from_fen]
    if type(s_content) is tuple:
        s_id = s_content[0]
    else:
        s_id = s_content
    t_content = nodes[to_fen]
    if type(t_content) is tuple:
        t_id = t_content[0]
    else:
        t_id = t_content
     
    CREATION.append( " MATCH (from:Position {id:"+str(s_id)+"}) " + \
                     " OPTIONAL MATCH (to:Position {id:"+str(t_id)+"})" + \
                     " MERGE (from)-[:Move {id:"+str(m_id)+", move:'" +move+ \
                        "', ordinal:" +str(ordinal)+ "}]->(to) ;" )

    # stop -= 1
    # if stop == 0: 
    #     break

########### 5) Adding index for positions to accelerate queries
# CREATION.append(';') # necessary to end previous transaction creating all Position nodes
# CREATION.append('CREATE INDEX i_move_id FOR ()-[m:Move]-() ON m.id;') <- forbidden: there is already a constraint ensuring this

# Ask for the removal of all positions not reachable from the initial position 
# (this happens maybe because the ipad app allowed to define positions in a book out of nowhere,
#   or because it was not cleaned properly when deleting moves leading to such positions)
CREATION.append(';')
# note:  :Move* is not working as it also lists node 0 (initial position) among others...
CREATION.append('MATCH (Position{id:0})-[*0..]->(conn:Position)'+ \
                   ' WITH collect(distinct conn) as connected' + \
                   ' MATCH (p:Position) WHERE NOT p IN connected DETACH DELETE p ;')

# TO DO : transform this into existence and uniqueness for a property key value (id for positions)
# # Q: is it the same for move id? <- relationship and no node)?
# CONSTRAINTs make the addition of nodes and relationships much slower...
# -> check unicity in Python then add the constraint only at the end to the neo4j script.
#CREATION.append('CREATE CONSTRAINT FOR (p:Position) REQUIRE p.id IS UNIQUE  ;')
#CREATION.append('CREATE CONSTRAINT FOR ()-[m:Move]->() REQUIRE m.id IS UNIQUE ;')

# Save to file with same prefix name:
filename = filename.removesuffix('.sqlite')+'.cypher'
with open(filename, 'w') as f:
    for line in CREATION:
        # write each item on a new line
        f.write("%s\n" % line)
    print('Done')

print('neo4j file created: ',filename)

#print("\n".join(CREATION))

