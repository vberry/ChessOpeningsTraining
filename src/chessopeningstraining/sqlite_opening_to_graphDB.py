# Transforms positions and notes from an sqlite db of the CPT (?) old ipad app
# into the creation of a graph for the neo4j graph database system

# PB: withou ';' at the end of queries or with the unique constraints first, the addition of nodes and moves
# is very slow !!!!!


import sqlite3
import sys
import chess
import re
from os import listdir
from os.path import isfile, join

from os import listdir
from os.path import isfile, join

def get_COT_formatted_fen(board):
    ''' remove the last part of the fen generated by the chess module as this part is not stored with positions in the COT database'''
    m = re.search(r'(.*)\s+\d+\s+\d+',board.fen())
    if m:
        return m.group(1)
    else:
        print('function get_COT_formatted_fen: regexp not correct to remove last part of large fen')
        sys.exit(-1)

def fen_after_move(fen,move):
    '''Generate the fen of the position obtained by playing <move> on the given <fen>'''
    board = chess.Board(fen)
    board.push_san(move)
    return get_COT_formatted_fen(board)

##########    MAIN   #################
if len(sys.argv)<2:
    print("\t\tUsage: "+sys.argv[0]+' <folder_containing_sqlite files>')
    sys.exit(-1)
mypath = sys.argv[1]

index = 0 ; files = []
for f in listdir(mypath):
    if isfile(join(mypath, f)) and f.endswith('.sqlite'):
        print(index,' : ',f)
        files.append(f) ; index += 1
choice = int(input('Which file to transform? '))
filename=join(mypath, files[choice])
con = sqlite3.connect(filename)
cur = con.cursor()
###  GET all positions : 
cur.execute("SELECT id,fromfen,move,ordinal FROM positions")
positionsLITE = cur.fetchall()
print('nb of positions in this opening book = ',len(positionsLITE)) 

# Load positions in a dictionary
SQlite_positions = {}  
SQlite_from_fens = {} 
for (id,fromfen,move,ordinal) in positionsLITE:
    if id in SQlite_positions:
        print('ERROR: id ',id,' is not unique in the sqlite db!')
        sys.exit(-1)
    SQlite_positions[id] = {'fromfen':fromfen,'move':move,'ordinal':ordinal}
    if fromfen in SQlite_from_fens: 
        SQlite_from_fens[fromfen].append((id,move)) 
    else: 
        SQlite_from_fens[fromfen] = [(id,move)] # adds the move of the SQlite position and ordinal of this move

# Generate data structures for the positions and moves to be stored in the graph db
nodes = {} # fen to id in the graphDB
moves = {} # move_id relating a 'from' and a 'to' positions (the move_id is taken from the SQLite position)

# Adds the initial position in the graphDB with id 0
if 0 in SQlite_positions:
    print("Houston we have a pbm: id 0 is already taken by a 'position' of the SQlite db")
    sys.exit(-2)

init_fen = get_COT_formatted_fen(chess.Board())
nodes[init_fen] = 0 ; node_id = 1 # ready for next node addition

# In fact each 'position in the SQlite DB is in fact a move" -> we prepare it as this in the graphDB
for id in SQlite_positions:
    # if id already seen we have duplicate ids:
    if id in moves:
        print("Duplicate position ids in SQlite db")
        sys.exit(-1)
    # is the starting position already known? Otherwise we create it for the graphDB
    starting_fen = SQlite_positions[id]['fromfen']
    if starting_fen not in nodes:
        nodes[starting_fen] = node_id ; node_id += 1
    # for this position we reach a new position:
    resulting_fen = fen_after_move(starting_fen,SQlite_positions[id]['move'])
    #print('resulting board :', chess.Board(resulting_fen))
    # we add this posÂ° node if not already registered (could be because of different move order)
    if resulting_fen not in nodes:
        nodes[resulting_fen] = node_id ; node_id += 1
    # Now we add the move between the two
    moves[id] = {'label': SQlite_positions[id]['move'], 'from': starting_fen, 'to':resulting_fen, 'ordinal':SQlite_positions[id]['ordinal']} 

print('Nb of nodes for the graph DB = ',len(nodes.keys()))
print('Nb of moves for the graph DB = ',len(moves.keys()))

# Getting notes stored in the opening book
cur.execute("SELECT notes.note, notes.fromfen, notes.id from notes")
notes = cur.fetchall() # tuples (comment,fen)
# Adding notes to the corresponding fen
unreferenced = 0
for (comment,fen,id) in notes:
    if fen not in nodes:
        # sometimes a note is not in the positions table or obtained from it (ie, the sqlite db was not correctly maintained)
        # print('PBM: note %s corresponds to a position note in the Positions table!' % id)
        # print('comment is ',comment)
        # print('fens is: ',fen)
        unreferenced += 1
    else:
        nodes[fen] = (nodes[fen], comment) # (id,comment)
print('Skipping %d notes not corresponding to actual positions' % unreferenced)
print('Reporting %d notes' % (len(notes)-unreferenced))

stop = 5
# Create graph nodes 
CREATION = ['CREATE CONSTRAINT FOR (p:Position) REQUIRE p.id IS UNIQUE  ;']
CREATION.append('CREATE CONSTRAINT FOR ()-[m:Move]->() REQUIRE m.id IS UNIQUE ;')
for fen,content in nodes.items():
    if type(content) == tuple:
        (id,comment) = content
        # handling quote characters as we use quote for the neo4j litteral:
        #comment = 'a nice " ouble quote"'
        comment = comment.replace("'","\\'") # single quotes
        comment = comment.replace('"','\\"') # double quotes
        # '\n' two-character sequence is not a pbm (checked) 
        CREATION.append( "CREATE (n"+str(id)+":Position {id: "+str(id)+", fen:'"+fen+"', comment:'"+comment+"'});" ) 
    else:
        id = content
        CREATION.append( "CREATE (n"+str(id)+":Position {id: "+str(id)+", fen:'"+fen+"'});" ) 

#print(CREATION)
    # stop -= 1
    # if stop == 0: 
    #     break
# sys.exit(1)

# Create move relationships
stop = 5
for m_id in moves:
    move = moves[m_id]['label']
    from_fen = moves[m_id]['from']
    to_fen = moves[m_id]['to']
    ordinal = moves[m_id]['ordinal']
    s_content = nodes[from_fen]
    if type(s_content) is tuple:
        s_id = s_content[0]
    else:
        s_id = s_content
    t_content = nodes[to_fen]
    if type(t_content) is tuple:
        t_id = t_content[0]
    else:
        t_id = t_content
    CREATION.append( "CREATE (n"+str(s_id)+")-[:Move {id: "+str(m_id)+", move:'"+move+"', ordinal:"+str(ordinal)+"}]->(n"+str(t_id)+");" )
            
    # stop -= 1
    # if stop == 0: 
    #     break

# Ask for the removal of all positions not reachable from the initial position 
# (this happens maybe because the ipad app allowed to define positions in a book out of nowhere,
#   or because it was not cleaned properly when deleting moves leading to such positions)
CREATION.append('MATCH (Position{id:0})-[:MOVE*]->(conn:Position) \
                    WITH collect(distinct conn) as connected \
                    MATCH (p:Position) WHERE NOT p IN connected DETACH DELETE p ;')

# Save to file with same prefix name:
filename = filename.removesuffix('.sqlite')+'.cypher'
with open(filename, 'w') as f:
    for line in CREATION:
        # write each item on a new line
        f.write("%s\n" % line)
    print('Done')

print('neo4j file created: ',filename)

#print("\n".join(CREATION))

